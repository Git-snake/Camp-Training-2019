<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

## 冒泡

#### 算法流程

![](./images/bubbleSort.gif)

#### 算法模板

```c++
for (int i = 0; i < n; i++)
    for (int j = 1; j < n - i; j++)
        if (a[j - 1] > a[j]) swap(a[j - 1], a[j]);
```



## 选择

#### 算法流程

![](./images/selectionSort.gif)

#### 算法模板

```c++
for (int i = 0; i < n - 1; i++) {
    int loc = i;
    for (int j = i + 1; j < n; j++) if (a[j] < a[loc]) loc = j;
    swap(a[loc], a[j]);
}
```



## 插入

#### 算法流程

![](./images/insertionSort.gif)

#### 算法模板

```c++
for (int i = 1; i < n; i++)
    for (int j = i - 1; j >= 0 && a[j] > a[j + 1]; j--)
        swap(a[j], a[j + 1]);
```







## 快排（分治）

#### 算法流程

1. 确定分界点 x（a[l], a[r], a[mid], 随机）
2. **调整区间**（左边所有数 <= x，右边所有数 >= x）
   1. 浪费额外空间
      1. 开两个额外数组 b, c
      2. 扫描区间，对于 a[i] <= x，放进 b。a[i] >= x，放进 c
      3. 然后把 b 放进 a，再把 c 放进 a
   2. 优雅做法
      1. 两个指针 i，j，分别从两端开始，往中间走
      2. 如果 a[i] <= x i++，直到 a[i] >= x，i 停止（错位，应该放右边）
      3. 如果 a[j] >= x j--，知道 a[j] <= x，j 停止（错位，应该放左边）
      4. swap(a[i], a[j])
3. 递归处理左右两段

#### 模板

```c++
void quick_sort(int a[], int l, int r) {
    if (l >= r) return;
    
    int x = a[l + (rand() % (r - l + 1))];
    int i = l - 1, j = r + 1;
    while (i < j) {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}
```

* 模板里为什么不写 quick_sort(a, l, i)
  * 因为 i 出来的时候，指向的是一个 >= x 的数，所以得写
    * quick_sort(a, l, i - 1)
    * quick_sort(a, i, r)
  * x 不能取 a[l]，会死循环
    * 1 2，i = 1，j = 0
    * quick_sort(a, 0, -1); quick_sort(a, 0, 1);



## 归并排序（分治）

#### 算法流程

![](./images/merge.png)

![](./images/merge2.png)

![](./images/mergeSort.gif)

1. 确定分界点 mid = (l + r) / 2
2. 递归排序左边和右边
3. **归并**（合二为一）
   1. 两个指针 i j，只想两个序列的开头
   2. 两个指针 较小值放进 第二个数组，指针往后移
   3. 把序列剩下的部分放进第二个数组

#### 模板

~~~c++
void merge_sort(int a[], int l, int r, int c[]) {
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(a, l, mid, c), merge_sort(a, mid + 1, r, c);
    int i = l, j = mid + 1;
    for (int k = l; k <= r; k++)
        if (j > r || i <= mid && a[i] <= a[j]) c[k] = a[i++];
    	else c[k] = a[j++];
   	for (int k = l; k <= r; k++) a[k] = c[k];
}
~~~



## 整数二分

#### 算法思想

在区间内，左半边不满足，右半边满足，寻找边界点。

#### 算法流程

1. 寻找左边的右端点
   1. mid = l + r + 1 >> 1
   2. check(mid) 
      1. true: l = mid
      2. false: r = mid - 1
2. 寻找右边的左端点
   1. mid = l + r >> 1
   2. check(mid)
      1. true: r = mid
      2. false: l = mid + 1

#### 模板

~~~c++
int bsearch_1(int l, int r) {
    while (l < r) {
        int m = l + r + 1 >> 1;
        if (check(m)) l = m;
        else r = m - 1;
    }
    return l;
}

int bsearch_2(int l, int r) {
    while (l < r) {
        int m = l + r >> 1;
        if (check(m)) r = m;
        else l = m + 1;
    }
    return l;
}
~~~



## 浮点数二分

#### 算法流程

1. mid = (l + r) / 2;
2. check(mid)
   1. true: l = mid
   2. false: r = mid

#### 算法模板

```c++
double bsearch_1(double l, double r) {
    while (r - l > 1e-8) {
        double m = (l + r) / 2;
        if (check(m)) l = m;
        else r = m;
    }
    return l;
}

double bsearch_2(double l, int double r) {
    for (int i = 0; i < 100; i++) {
        double m = (l + r) / 2;
        if (check(m)) l = m;
        else r = m;
    }
    return l;
}
```



## 高精度加法

#### 算法思想

模拟竖式

#### 算法模板

~~~c++
vector<int> add(vector<int> & a, vector<int> & b) {
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) t += a[i];
        if (i < b.size()) t += b[i];
        c.push_back(t % 10);
        t /= 10;
    }
    if (t) c.push_back(1);
    
    return c;
}
~~~





## 高精度减法

#### 算法步骤

1. 比较两个数A，B的大小，让大的减去小的
2. 做减法
3. 去除前导0

#### 算法模板

~~~c++
bool cmp (const vector<int> & A, const vector<int> & B) {
    if (A.size() != B.size()) return A.size() > B.size();
    for (int i = A.size() - 1; i >= 0; i--)
        if (A[i] != B[i]) return A[i] > B[i];
    return true;
}

vector<int> sub(const vector<int> & A, const vector<int> & B) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || i < B.size(); i++) {
        t += A[i];
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = -1;
        else t = 0;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
~~~





## 大整数乘以小整数

#### 算法步骤

1. t += A[i] * b
2. 把 t % 10，即最低位的结果放进答案
3. t /= 10，t 舍弃最低位
4. 最后需要去除前导0

#### 模板

~~~c++
vector<int> mul(const vector<int> & A, int b) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i++) {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
~~~





## 大整数除以小整数

#### 算法步骤

1. 每次从最大位开始，取一个，整除 b
2. 结果放进答案，余数再对 b 取余
3. 最后把结果反过来，因为我们的存储格式应该是低位在前
4. 去前导0



#### 算法模板

~~~c++
vector<int> div(const vector<int> & A, int b, int & r) {
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i--) {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
~~~



## 大数乘以大数

#### 算法思想

利用大数和大数的加法，以及大数和小数的乘法，组合出来



#### 算法模板

```c++
vector<int> mul(const vector<int> & A, const vector<int> & B) {
    vector<int> ans = vector<int>(1, 0);		// 初始化只有一位，为0
    for (int i = B.size() - 1; i >= 0; i--) {
        ans = mul(ans, 10);						// 往左移一位
        ans = add(ans, mul(A, B[i]));
    }
    return ans;
}
```



## 大数的取模

#### 算法思想

$123\ mod\ 7\\ =(1\times10^2 + 2\times10^1 + 3\times10^0)\ mod\ 7\\=(1\times10^2\  mod\ 7 + 2\times10^1\ mod\ 7 + 3\times10^0\ mod\ 7)\ mod\ 7\\$



#### 算法模板

```c++
int mod(const vector<int> & A, int p) {
    int ans = 0;
    for (int i = A.size() - 1; i >= 0; i--) ans = (ans * 10 + A[i]) % p;
    return ans;
}
```

