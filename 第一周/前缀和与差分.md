# 前缀和
## 前缀和是一种重要的预处理，能大大降低查询的时间复杂度，我们可以简单理解为“数列的前n项的和”  
### 例题
有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。  
对于这道题，我们有俩种做法：
#### 把对数组A的累加依次放入数组B中
#### 递推 ： b[i]=b[i-1]+a[i],前提 b[0]=a[0]。
```
#include <iostream>

using namespace std;

int N, A[10000], B[10000];
int main() {
  cin >> N;
  for (int i = 0; i < N; i++) {
    cin >> A[i];
  }

  B[0] = A[0];

  for (int i = 1; i < N; i++) {
    B[i] = B[i - 1] + A[i];
  }

  for (int i = 0; i < N; i++) {
    cout << B[i] << " ";
  }

  return 0;
}
```
首先， B[0] = A[0]; ，前缀和数组的第一项和原数组的第一项是相等的。
B[i] = B[i-1] + A[i] 意思就是：前缀和数组的第 i 项 = 原数组的 0 到 i-1 项的和 + 原数组的第 i 项。前缀和的数学定义为： $s[i]\sum_{j=1}^iA[i]$  
# 二维前缀和
 其实前缀和几乎都是基于容斥原理，所以各种拓展自己手推一下就行了。
这里用二维前缀和为例讲解一下前缀和扩展到多维的方式。  
我们定义一个矩阵sum，$sumxy=\sum_{j=1}^x\sum_{j=1}^yA[i][j]$ 
# 差分
差分，是一种和前缀和相对的策略。  
这种策略是，令$bi=ai-ai-1$即相邻两数的差。
易得对这个序列做一遍前缀和就得到了原来的a序列它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的数。

